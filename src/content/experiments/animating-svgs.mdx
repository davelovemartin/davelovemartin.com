---
title: Animating SVGs
description: How SVGs work and how to animate them
lastEdited: 06.08.2023
type: experiment
---

import { Prism } from "@astrojs/prism";
import SvgExample from "@experiments/SvgExample.astro";
import SvgPathExample from "@experiments/SvgPathExample.astro";
import BouncingBallCSSKeyframes from "@experiments/BouncingBallCSSKeyframes.jsx";
import BouncingBallGsap from "@experiments/BouncingBallGsap.jsx";
import Graphic from "@components/Graphic.astro";
import GraphicBackground from "@components/GraphicBackground.jsx";

When I started to learn to code websites, there were a few different options for creating icons. You could use a sprite sheet, or use a special icon font...

...but I always liked the idea of SVGs.

After all they are scalable, so they can be created with a small footprint but can be blown up to fill any large screen without loss of definition. And as a subset of XML, they can be written inline in HTML and targetted with CSS.

Whilst the other techniques have fallen out of fashion, SVGs are here to stay.

You can also import SVGs as JSX, in React (although [you may not want to do that](https://kurtextrem.de/posts/svg-in-js)).

You can create SVGs in your favourite Vector Graphic editing software, and export the code created and plonk it into your code. You can use the excellent [SVGOMG](https://jakearchibald.github.io/svgomg/) tool, to optimise the code as your favourite Vector Graphic software may add some extra bloat.

However, I thought it would be great to get under the hood and explore how to create SVGs from scratch.

## The SVG element

In HTML, there is a SVG element which you can use to render a SVG document fragment. The viewBox attribute defines the coordinates of your viewport. The window into your SVG world.

The first two numbers in the viewBox denote the top left co-ordinates of the viewport and the last two numbers represent the width and length of the viewport.

<Prism lang="svg" code={`<svg viewBox="0 0 100 100" />`} />

<GraphicBackground>
  <SvgExample />
</GraphicBackground>

You can add shape elements as children of an SVG. They are ‘circle’, ‘ellipse’, ‘line’, ‘polygon’, ‘polyline’, ‘rect’ and ‘path’.

You can probably take a reasonable guess at what these shapes are. The most flexible one is the path element.

The path element is defined along with a path data property, **d**. The path data is a series of commands that tell the browser how the path should be drawn — in a similar way to how you might program a robot turtle.

Here, I use the move command (**M**), along with the line command (**L**) and the closepath command (**Z**) to draw a polygon.

<Prism
  lang="svg"
  code={`<svg viewBox="0 0 100 100">
  <path d="M 0 40 L 50 0 L 100 60 L 30 70 Z" fill="none" stroke="#2c363f"></path>
</svg>`}
/>

<GraphicBackground>
  <SvgPathExample />
</GraphicBackground>

The command code can either be uppercase or lowercase:

- uppercase commands are absolute — their parameters are relative to the origin point,
- lowercase commands are relative to the previous command's endpoint.

**This is a work in progress — more to come soon**

## Animation methods

### Animating with CSS only

This example uses CSS Keyframes to animate a ball:

<Graphic>
  <BouncingBallCSSKeyframes />
</Graphic>

here's the css I used:

<Prism
  lang="css"
  code={`@keyframes bounce {
  from {
    transform: translateY(0);
  }
  to {
    transform: translateY(160px);
  }
}
.ball {
  animation-name: bounce;
  animation-duration: 1s;
  animation-timing-function: ease-in-out;
  animation-delay: 0s;
  animation-iteration-count: infinite;
  animation-direction: alternate;
  animation-fill-mode: forwards;
  fill: var(--color-highlight);
}`}
/>

### Animating with a javascript library

Here, I'm using <a href="https://greensock.com/gsap/">GSAP</a> to scale the circle's X and Y dimensions to simulate how balls deform when colliding with the floor:

<Graphic>
  <BouncingBallGsap client:visible />
</Graphic>
